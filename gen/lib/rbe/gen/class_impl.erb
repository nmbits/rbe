% c = target

#include "rbe.hpp"
#include "convert.hpp"
#include "call_script.hpp"
#include "protect.hpp"
#include "gvl.hpp"
#include "lock.hpp"
#include "debug.hpp"
#include "member.hpp"
// #include "memorize.hpp"
#include "registory.hpp"
#include "ownership.hpp"

#include "<%= class_binding_header c.name %>"

% c.dependencies.each do |name|
#include "<%= class_binding_header name %>"
% end

% if c.mixin_name
#include "<%= class_binding_header c.mixin_name %>"
% end

#include <utility>

namespace rbe {
	namespace B {
		VALUE <%= class_binding_name c.name %>::sClass = Qnil;
		const rb_data_type_t <%= class_binding_name c.name %>::sDataType = {
			"b/<%= underscore class_binding_name(c.name) %>",
			{
				(void (*)(void *)) &<%= class_binding_name c.name %>::rbe__gc_mark,
				(void (*)(void *)) &<%= class_binding_name c.name %>::rbe__gc_free,
				(size_t (*)(const void *)) &<%= class_binding_name c.name %>::rbe__gc_size
			}
		};

% unless c.wrapper?
		VALUE <%= class_binding_name c.name %>::Wrap(<%= c.name %> *obj)
		{
			PointerOf<<%= c.name %>>::Class *ptr = static_cast<PointerOf<<%= c.name %>>::Class *>(obj);
			VALUE result = ObjectRegistory::Instance()->Get(ptr);
			if (result == Qnil) {
				result = TypedData_Wrap_Struct(sClass, &sDataType, ptr);
				ObjectRegistory::Instance()->Add(result);
			}
			return result;
		}

% end
<%= template :hooks_impl, c %>

% c.find_functions(:ctor => false).each do |fn|
%   next if fn.ignore? || fn.custom?
<%= template :method_impl, c, fn %>
% end

<%= template :variables_impl, c %>

% unless c.ctor.custom? || c.module?
<%= template :ruby_init_impl, c %>

% end
<%= template :ruby_intf_impl, c %>

<%= template :ruby_class_init, c %>
	} // namespace B
} // namespace rbe
